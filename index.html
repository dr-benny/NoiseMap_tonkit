<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Leaflet with GeoServer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      #map {
        height: 100vh;
      }
      .leaflet-div-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }

      .leaflet-popup-content {
        font-size: 14px;
      }

      /* Legend styles */
      .legend {
        background-color: white;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
      }

      .legend h4 {
        margin-bottom: 5px;
        font-size: 16px;
      }

      .legend .color-box {
        width: 20px;
        height: 20px;
        display: inline-block;
      }
      .popup-content .my-3 {
        width: 600px;
        height: 300px;
      }

      .leaflet-popup-content {
        width: auto !important;
      }
    </style>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0"></script>

    <script src="https://cdn.jsdelivr.net/npm/luxon@3.0.0/build/global/luxon.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <!-- เพิ่มใน <head> -->
    <script src="https://unpkg.com/leaflet.nontiledlayer@1.0.8/dist/NonTiledLayer.js"></script>

    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet"
    />
  </head>

  <body>
    <div id="map"></div>
    <script>
      $(document).ready(function () {
        //Set start point at user location

        //BaseMap
        var terrainLayer = L.tileLayer(
          "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          {
            maxZoom: 19, // OSM max zoom level is usually 19
            opacity: 0.8,
            minZoom: 5,
            attribution: "© OpenStreetMap contributors",
          }
        );
        var blackOverlay = L.rectangle(
          [
            [-90, -180],
            [90, 180],
          ], // Covers the whole world
          {
            color: "black", // Border color (optional)
            weight: 0, // No border
            fillColor: "black", // Fill color
            fillOpacity: 0.3, // Adjust darkness (0.0 = fully transparent, 1.0 = fully black)
          }
        );
        let hexOverlay;

        function updateHexLayer() {
          const bounds = map.getBounds();
          const size = map.getSize();

          const wmsUrl =
            "http://localhost:8080/geoserver/it.geosolutions/wms?" +
            L.Util.getParamString({
              service: "WMS",
              version: "1.1.0",
              request: "GetMap",
              layers: "it.geosolutions:hex_005_e2f8",
              styles: "hex",
              format: "image/png",
              transparent: true,
              srs: "EPSG:4326",
              bbox: bounds.toBBoxString(),
              width: size.x,
              height: size.y,
              tiled: false,
              TILED: false,
            });

          if (hexOverlay) {
            map.removeLayer(hexOverlay);
          }

          hexOverlay = L.imageOverlay(wmsUrl, bounds, { opacity: 0.9 }).addTo(
            map
          );
        }

        var satelliteLayer = L.tileLayer(
          "https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
          {
            maxZoom: 19,
            opacity: 0.8,
            minZoom: 5,
            subdomains: ["mt0", "mt1", "mt2", "mt3"],
            attribution: "© Google Maps",
          }
        );
        const map = L.map("map", {
          zoom: 2, // Adjust zoom level
          layers: [terrainLayer, blackOverlay],
        }).setView([13.756111, 100.516667], 13);

        map.on("moveend zoomend", updateHexLayer);
        updateHexLayer();
        map.on("click", async (e) => {
          const lat = e.latlng.lat;
          const lng = e.latlng.lng;
          try {
            // 1️⃣ เรียก GetFeatureInfo เพื่อดูว่าอยู่ใน hex ไหน
            const wmsUrl =
              "http://localhost:8080/geoserver/it.geosolutions/wms?";
            const layer = "it.geosolutions:hex_005_e2f8";
            const bbox = `${lng - 0.001},${lat - 0.001},${lng + 0.001},${
              lat + 0.001
            }`;

            const getFeatureInfoUrl =
              `${wmsUrl}?service=WMS&version=1.1.1&request=GetFeatureInfo` +
              `&layers=${layer}` +
              `&query_layers=${layer}` +
              `&info_format=application/json` +
              `&x=50&y=50&srs=EPSG:4326&width=101&height=101&bbox=${bbox}`;

            const res = await fetch(getFeatureInfoUrl);
            if (!res.ok)
              throw new Error(`GetFeatureInfo failed: ${res.status}`);

            const json = await res.json();
            if (!json.features || json.features.length === 0) {
              console.warn("No hex found at clicked point");
              return;
            }

            const feature = json.features[0];
            // แปลงพิกัดเป็น "lng lat lng lat ..." สำหรับ gml:posList
            const coordsList = feature.geometry.coordinates[0]
              .map((c) => `${c[0]} ${c[1]}`) // เปลี่ยนกลับเป็น lng lat
              .join(" ");

            console.log("Hex coordinates:", coordsList);

            // 2️⃣ ใช้ geometry ของ hex ไป query raw_data ด้วย WFS
            const wfsUrl = "http://localhost:3000/wfs-proxy";
            const wfsXml = `
<wfs:GetFeature service="WFS" version="1.1.0" maxFeatures="1000" outputFormat="application/json"
  xmlns:wfs="http://www.opengis.net/wfs"
  xmlns:gml="http://www.opengis.net/gml"
  xmlns:ogc="http://www.opengis.net/ogc">
  <wfs:Query typeName="it.geosolutions:noise_spatial_table">
    <ogc:Filter>
      <ogc:Intersects>
        <ogc:PropertyName>coordinate</ogc:PropertyName>
        <gml:Polygon srsName="EPSG:4326">
          <gml:exterior>
            <gml:LinearRing>
              <gml:posList>${coordsList}</gml:posList>
            </gml:LinearRing>
          </gml:exterior>
        </gml:Polygon>
      </ogc:Intersects>
    </ogc:Filter>
    <ogc:SortBy>
      <ogc:SortProperty>
        <ogc:PropertyName>time</ogc:PropertyName>
        <ogc:SortOrder>DESC</ogc:SortOrder>
      </ogc:SortProperty>
    </ogc:SortBy>
  </wfs:Query>
</wfs:GetFeature>
`;

            const res2 = await fetch(wfsUrl, {
              method: "POST",
              headers: { "Content-Type": "text/xml" },
              body: wfsXml.trim(),
            });

            if (!res2.ok) throw new Error(`WFS query failed: ${res2.status}`);

            const data = await res2.text();
            console.log("WFS response:", data);
          } catch (err) {
            console.error("Error:", err);
          }
        });

        //hexLayer.addTo(map);
        // Determine marker color based on noise level
        function getMarkerColor(noiseLevel) {
          if (noiseLevel > 70) return "red";
          else if (noiseLevel > 50) return "orange";
          else return "green";
        }

        // Load GeoJSON from GeoServer
        function loadGeoJSON() {
          // fetch data
          $.ajax({
            url: "http://localhost:8080/geoserver/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=it.geosolutions:current_noise&outputFormat=application/json",
            method: "GET",
            success: function (data) {
              if (data && data.features) {
                L.geoJSON(data, {
                  pointToLayer: function (feature, latlng) {
                    const markerColor = getMarkerColor(
                      feature.properties.noise_level
                    );

                    const geojsonMarkerOptions = {
                      radius: 10,
                      fillColor: markerColor,
                      color: "#000",
                      weight: 1,
                      opacity: 1,
                      fillOpacity: 0.8,
                    };
                    return L.circleMarker(latlng, geojsonMarkerOptions);
                  },
                  onEachFeature: function (feature, layer) {
                    const time = new Date(
                      feature.properties.time
                    ).toLocaleString();
                    const popupContent = `

                    <div class="popup-content p-3 " style="width:20rem">

          <div style="font-size:1rem"> ID:1 | TonkitLab |
            <i id="battery-icon" class="fa fa-battery-full" ></i>
            <span id="battery-percentage" >100%</span>
          </div>




                        <p><span class="fw-bold">Noise Level:</span> ${feature.properties.noise_level} dB(A)</p>
                        <p><span class="fw-bold">Latest Time:</span> ${time}</p>
                            <button style="margin-top:0.2rem;border-radius:1rem" class="btn btn-primary btn-sm popup-btn w-100 fw-bold" data-id="${feature.properties.id}">More Info <i class="fa-solid fa-eye"></i></button></div>

                `;
                    layer.bindPopup(popupContent);
                    layer.moreInfoShow = false;
                    // Attach event listener for button
                    layer.on("popupopen", function () {
                      if (!layer.moreInfoShow) {
                        layer.bindPopup(popupContent);
                        $(".popup-btn").on("click", function () {
                          fetchAdditionalInfo($(this).data("id"), layer);
                        });
                      } else {
                        fetchAdditionalInfo($(this).data("id"), layer);
                      }
                    });
                  },
                }).addTo(map);
              }
            },
            error: function (error) {
              console.error("Error fetching GeoJSON:", error);
            },
          });
        }
        ////////////
        function calculateLAeq(laeq1minArray) {
          if (laeq1minArray.length === 0) return 0;

          // Compute sum of sound energy using reduce
          const sum = laeq1minArray.reduce(
            (acc, val) => acc + Math.pow(10, val / 10),
            0
          );

          // Compute mean energy and LAeq,1h
          const laeq1h = 10 * Math.log10(sum / 60);
          return parseFloat(laeq1h.toFixed(1));
        }
        function downloadCSVFromArrays(
          timeLabels,
          noiseLevels,
          filename = "data.csv"
        ) {
          if (
            !timeLabels ||
            !noiseLevels ||
            timeLabels.length !== noiseLevels.length
          ) {
            console.error(
              "Both arrays must be provided and have the same length."
            );
            return;
          }

          // Create header row
          let csvContent = "Time,Noise Level\n";

          // Build rows
          for (let i = 0; i < timeLabels.length; i++) {
            // Wrap each value in quotes to handle commas and special characters
            const time = `"${timeLabels[i]}"`;
            const noise = `"${noiseLevels[i]}"`;
            csvContent += `${time},${noise}\n`;
          }

          // Create a Blob from the CSV content
          const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
          });
          const url = URL.createObjectURL(blob);

          // Create a temporary link element to trigger the download
          const link = document.createElement("a");
          link.setAttribute("href", url);
          link.setAttribute("download", filename);
          link.style.visibility = "hidden";

          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
        function formatDateForInput(date) {
          // Helper function to add a leading zero if needed
          const pad = (num) => (num < 10 ? "0" + num : num);

          const year = date.getFullYear();
          const month = pad(date.getMonth() + 1); // Months are zero-indexed
          const day = pad(date.getDate());
          const hours = pad(date.getHours());
          const minutes = pad(date.getMinutes());

          return `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        /*function updateBatteryIcon(batteryLevel) {
            const batteryIcon = document.getElementById('battery-icon');
            const batteryPercentage = document.getElementById('battery-percentage');

            // Update the percentage text
            batteryPercentage.textContent = `${batteryLevel}%`;

            // Determine the appropriate battery icon class
            let iconClass;
            if (batteryLevel > 75) {
              iconClass = 'fa-battery-full';
            } else if (batteryLevel > 50) {
              iconClass = 'fa-battery-three-quarters';
            } else if (batteryLevel > 25) {
              iconClass = 'fa-battery-half';
            } else if (batteryLevel > 10) {
              iconClass = 'fa-battery-quarter';
            } else {
              iconClass = 'fa-battery-empty';
            }

            // Update the icon's class
            batteryIcon.className = `fa ${iconClass}`;
          }
                   */

        // Fetch additional information and update the popup
        function fetchAdditionalInfo(id, layer) {
          $.ajax({
            url: `http://localhost:8080/geoserver/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=it.geosolutions:noise_spatial_table&outputFormat=application/json&CQL_FILTER=INTERSECTS(coordinate,POINT(${layer.feature.geometry.coordinates[0]} ${layer.feature.geometry.coordinates[1]}))&SORTBY=time+D&maxFeatures=60`,
            method: "GET",
            success: function (data) {
              console.log(data);
              const laeq1minArray = new Array(data.features.length);
              const labels = new Array(data.features.length);

              let index = data.features.length - 1;
              data.features.forEach((feature) => {
                laeq1minArray[index] = feature.properties.noise_level;
                labels[index] = new Date(
                  feature.properties.time
                ).toLocaleString();
                index--;
              });

              const additionalContent = `
          <div id="battery-container" class="position-absolute badge bg-black" style="right:3rem;top:5.8rem">
            <i id="battery-icon" class="fa fa-battery-full" style="font-size:1rem;"></i>
            <span id="battery-percentage" style="font-size:1.2rem">100%</span>
          </div>

                        <div class="position-absolute bg-warning badge" style="right:2.5rem;top:2.6rem;font-size:1.4rem;color:black;border-radius:0.8rem;"> ID:1 | TonkitLab </div>
                        <div class="popup-content container p-3">
                          <div>
                          <p>
                            <span class="h6 fw-bold text-secondary">LAeq <span id="LaeqTypes">1hr<span>: </span>
                            <span class="h4 fw-bold"><i class="fa fa-microphone"></i> <span id="LaeqValue">${calculateLAeq(
                              laeq1minArray
                            )}</span>
                            </span>
                            <span class="badge bg-primary" style="font-size:0.9rem;margin-left:0.2rem;">dB(A)</span>
                          </p>
                          </div>



                          <div class="mb-3 mt-5">
                            <label for="time-filter" class="form-label fw-bold h6 text-secondary">Select Time Range:</label>

                            <div class="input-group row">
          <div class="col"><div class="p-1 badge bg-success mb-1 fw-bold"style="font-size:0.9rem;">START <i class="fa-solid fa-clock"></i></div></div>

                              <div class="col"><div class="p-1 badge bg-danger mb-1 fw-bold"style="font-size:0.9rem;">END <i class="fa-solid fa-clock"></i></div></div>


                              <div class="w-100"></div>


                            <div class="col">
                             <input type="datetime-local" id="start-time" class="form-control me-2 " value="${formatDateForInput(
                               new Date(data.features.pop().properties.time)
                             )}"/>
                             </div>

                              <div class="col">
                              <input type="datetime-local" id="end-time" class="form-control me-2" value="${formatDateForInput(
                                new Date(data.features[0].properties.time)
                              )}"/>
                             </div>


                            </div>

                          </div>

                          <button id="update-chart" class="btn btn-primary w-100 my-2">Update Chart</button>

                          <div class="my-3">
                            <canvas id="noiseChart" class="border rounded shadow-sm"></canvas>
                          </div>

                          <div class="d-flex justify-content-between">
                            <button class="popup-btn-back btn btn-secondary">Back</button>
                            <div>
                            <button id="downloadCSVButton" class="btn btn-primary" style="margin-right:0.5rem">Download CSV</button>
                            <button id="downloadChart" class="btn btn-success">Download Chart</button>
                            </div>
                          </div>
                        </div>
                      `;

              layer.bindPopup(additionalContent);
              layer.moreInfoShow = true;

              const thresholdValue = 50; // Set your desired threshold
              // Generate an array for point colors: red if above threshold, otherwise the default color.
              const pointColors = laeq1minArray.map((value) =>
                value > thresholdValue ? "red" : "rgba(75, 192, 192, 1)"
              );

              // Optionally, adjust point radii: larger if above threshold.
              const pointRadii = laeq1minArray.map((value) =>
                value > thresholdValue ? 6 : 4
              );

              // Count the number of points above the threshold.
              const aboveThresholdCount = laeq1minArray.filter(
                (value) => value > thresholdValue
              ).length;
              const countPlugin = {
                id: "countPlugin",
                afterDraw: (chart, args, options) => {
                  const {
                    ctx,
                    chartArea: { top, left, right },
                  } = chart;
                  ctx.save();
                  ctx.font = options.font || "16px sans-serif";
                  ctx.fillStyle = options.color || "black";
                  ctx.textAlign = "right";
                  ctx.textBaseline = "top";
                  const text = options.text || "";
                  // Draw text at the top center of the chart area.
                  ctx.fillText(text, right, top - 25);
                  ctx.restore();
                },
              };

              // Register the custom plugin with Chart.js.
              Chart.register(countPlugin);

              const canvas = document.getElementById("noiseChart");
              if (!canvas) return; // Prevent errors if popup closes before render

              const ctx = canvas.getContext("2d");
              layer.chartInstance = new Chart(ctx, {
                type: "line",
                data: {
                  labels: labels,
                  datasets: [
                    {
                      label: "Noise Levels",
                      data: laeq1minArray,
                      borderColor: "rgba(75, 192, 192, 1)",
                      borderWidth: 2,
                      fill: false,
                      pointStyle: "circle",

                      pointBackgroundColor: pointColors,
                      pointRadius: pointRadii,
                    },
                  ],
                },
                options: {
                  responsive: true,
                  plugins: {
                    zoom: {
                      zoom: {
                        wheel: {
                          enabled: true,
                        },
                        pinch: {
                          enabled: true,
                        },
                        mode: "xy",
                      },
                      limits: {
                        x: {
                          min: 0, // Set the minimum value for the x-axis
                          max: 60, // Set the maximum value for the x-axis
                        },
                        y: {
                          min: 0, // Set the minimum value for the y-axis
                          max: 100, // Set the maximum value for the y-axis
                        },
                      },
                    },
                    legend: {
                      display: true,
                      position: "top", // or 'bottom', 'left', 'right'
                      labels: {
                        // Enable point style in legend and set desired point shape
                        usePointStyle: true,
                        pointStyle: "circle",
                        padding: 20,
                        font: {
                          size: 14,
                        },
                        color: "#333",
                      },
                    },
                    annotation: {
                      annotations: {
                        thresholdLine: {
                          type: "line",
                          yMin: thresholdValue,
                          yMax: thresholdValue,
                          borderColor: "red",
                          borderWidth: 2,
                          label: {
                            content: "Threshold",
                            enabled: true,
                            position: "end",
                            backgroundColor: "rgba(255, 0, 0, 0.8)",
                          },
                        },
                      },
                    },
                    // Configure the custom plugin to display the count
                    countPlugin: {
                      text: `Points above threshold: ${aboveThresholdCount}`,
                      font: "bold 1rem sans-serif",
                      color: "red",
                    },
                  },
                  scales: {
                    x: { display: false },
                  },
                },
              });
              // Update chart on time range change
              function toISOWithTimezone(date) {
                const offset = -date.getTimezoneOffset();
                const sign = offset >= 0 ? "+" : "-";
                const pad = (num) =>
                  String(Math.floor(Math.abs(num))).padStart(2, "0");
                return (
                  date.getFullYear() +
                  "-" +
                  pad(date.getMonth() + 1) +
                  "-" +
                  pad(date.getDate()) +
                  "T" +
                  pad(date.getHours()) +
                  ":" +
                  pad(date.getMinutes()) +
                  ":" +
                  pad(date.getSeconds()) +
                  sign +
                  pad(offset / 60) +
                  ":" +
                  pad(offset % 60)
                );
              }
              $("#update-chart").on("click", function () {
                const startTime = $("#start-time").val();
                const endTime = $("#end-time").val();
                if (startTime && endTime) {
                  const startDate = new Date(startTime);
                  const endDate = new Date(endTime);

                  const startTimeFormatted = toISOWithTimezone(startDate);
                  const endTimeFormatted = toISOWithTimezone(endDate);

                  // Create a spatial filter based on the feature's coordinates
                  const spatialFilter = `INTERSECTS(coordinate,POINT(${layer.feature.geometry.coordinates[0]} ${layer.feature.geometry.coordinates[1]}))`;

                  // Create a time filter using BETWEEN
                  const timeFilter = `time BETWEEN '${startTimeFormatted}' AND '${endTimeFormatted}'`;

                  // Combine both filters using AND
                  const combinedFilter = `${spatialFilter} AND ${timeFilter}`;
                  console.log(combinedFilter);

                  // Encode the filter string for the URL
                  const url = `http://localhost:8080/geoserver/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=it.geosolutions:noise_spatial_table&outputFormat=application/json&CQL_FILTER=${encodeURIComponent(
                    combinedFilter
                  )}&SORTBY=time`;

                  $.ajax({
                    url: url,
                    method: "GET",
                    success: function (data_update) {
                      layer.chartInstance.destroy();
                      layer.moreInfoShow = false;
                      const laeq1minArray = data_update.features.map(
                        (feature) => feature.properties.noise_level
                      );
                      const labels = data_update.features.map(
                        (feature) => feature.properties.time
                      );
                      const thresholdValue = 50; // Set your desired threshold
                      // Generate an array for point colors: red if above threshold, otherwise the default color.
                      const pointColors = laeq1minArray.map((value) =>
                        value > thresholdValue ? "red" : "rgba(75, 192, 192, 1)"
                      );

                      // Optionally, adjust point radii: larger if above threshold.
                      const pointRadii = laeq1minArray.map((value) =>
                        value > thresholdValue ? 6 : 4
                      );

                      function downsampleLTTB(data, targetCount) {
                        if (data.length <= targetCount) {
                          return data; // No downsampling needed
                        }

                        const result = [];
                        const bucketSize = data.length / targetCount;
                        let lastIndex = data.length - 1;

                        result.push(data[0]); // Always include the first point

                        for (let i = 1; i < targetCount - 1; i++) {
                          const start = Math.floor(i * bucketSize);
                          const end = Math.floor((i + 1) * bucketSize);

                          let maxArea = 0;
                          let maxAreaPoint = data[start];

                          // Find the point with the largest area
                          for (let k = start; k < end; k++) {
                            const area = Math.abs(
                              (data[start].x - data[end].x) *
                                (data[k].y - data[start].y) -
                                (data[start].x - data[k].x) *
                                  (data[end].y - data[start].y)
                            );

                            if (area > maxArea) {
                              maxArea = area;
                              maxAreaPoint = data[k];
                            }
                          }

                          result.push(maxAreaPoint);
                        }

                        result.push(data[lastIndex]); // Always include the last point
                        return result;
                      }

                      const targetPoints = 50; // Desired number of data points
                      const downsampledData = downsampleLTTB(laeq1minArray, 20);

                      console.log(laeq1minArray);
                      console.log(downsampledData);
                      // Count the number of points above the threshold.
                      const aboveThresholdCount = laeq1minArray.filter(
                        (value) => value > thresholdValue
                      ).length;
                      const countPlugin = {
                        id: "countPlugin",
                        afterDraw: (chart, args, options) => {
                          const {
                            ctx,
                            chartArea: { top, left, right },
                          } = chart;
                          ctx.save();
                          ctx.font = options.font || "16px sans-serif";
                          ctx.fillStyle = options.color || "black";
                          ctx.textAlign = "right";
                          ctx.textBaseline = "top";
                          const text = options.text || "";
                          // Draw text at the top center of the chart area.
                          ctx.fillText(text, right, top - 25);
                          ctx.restore();
                        },
                      };

                      // Register the custom plugin with Chart.js.
                      Chart.register(countPlugin);

                      const canvas = document.getElementById("noiseChart");
                      if (!canvas) return; // Prevent errors if popup closes before render

                      const ctx = canvas.getContext("2d");
                      layer.chartInstance = new Chart(ctx, {
                        type: "line",
                        data: {
                          labels: [
                            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                            16, 17, 18, 19, 20,
                          ],
                          datasets: [
                            {
                              label: "Noise Levels",
                              data: downsampledData,
                              borderColor: "rgba(75, 192, 192, 1)",
                              borderWidth: 2,
                              fill: false,
                              pointStyle: "circle",

                              pointBackgroundColor: pointColors,
                              pointRadius: 0,
                              spanGspd: false,
                              tension: 0.2,
                            },
                          ],
                        },
                        options: {
                          responsive: true,
                          plugins: {
                            zoom: {
                              zoom: {
                                wheel: {
                                  enabled: true,
                                },
                                pinch: {
                                  enabled: true,
                                },
                                mode: "xy",
                              },
                              limits: {
                                x: {
                                  min: 0, // Set the minimum value for the x-axis
                                  max: 60, // Set the maximum value for the x-axis
                                },
                                y: {
                                  min: 0, // Set the minimum value for the y-axis
                                  max: 100, // Set the maximum value for the y-axis
                                },
                              },
                            },
                            legend: {
                              display: true,
                              position: "top", // or 'bottom', 'left', 'right'
                              labels: {
                                // Enable point style in legend and set desired point shape
                                usePointStyle: true,
                                pointStyle: "circle",
                                padding: 20,
                                font: {
                                  size: 14,
                                },
                                color: "#333",
                              },
                            },
                            annotation: {
                              annotations: {
                                thresholdLine: {
                                  type: "line",
                                  yMin: thresholdValue,
                                  yMax: thresholdValue,
                                  borderColor: "red",
                                  borderWidth: 2,
                                  label: {
                                    content: "Threshold",
                                    enabled: true,
                                    position: "end",
                                    backgroundColor: "rgba(255, 0, 0, 0.8)",
                                  },
                                },
                              },
                            },
                            // Configure the custom plugin to display the count
                            countPlugin: {
                              text: `Points above threshold: ${aboveThresholdCount}`,
                              font: "bold 1rem sans-serif",
                              color: "red",
                            },
                          },
                          scales: {
                            x: { display: false },
                          },
                        },
                      });

                      $("#LaeqValue").text(calculateLAeq(laeq1minArray));
                    },
                  });
                } else {
                  alert("Please select both start and end times.");
                }
              });

              $("#downloadCSVButton").on("click", function () {
                downloadCSVFromArrays(labels, laeq1minArray, "noiseData.csv");
              });

              // Download chart functionality
              $("#downloadChart").on("click", function () {
                if (layer.chartInstance) {
                  const canvas = document.createElement("canvas");
                  const ctx = canvas.getContext("2d");
                  canvas.width = layer.chartInstance.canvas.width;
                  canvas.height = layer.chartInstance.canvas.height;

                  ctx.fillStyle = "white";
                  ctx.fillRect(0, 0, canvas.width, canvas.height);
                  ctx.drawImage(layer.chartInstance.canvas, 0, 0);

                  const link = document.createElement("a");
                  link.href = canvas.toDataURL("image/png");
                  link.download = "chart.png";
                  link.click();
                } else {
                  console.error("Chart instance is not available.");
                }
              });

              // Handle back button
              $(".popup-btn-back").on("click", function () {
                layer.closePopup();
                layer.chartInstance.destroy();
                layer.moreInfoShow = false;
                setTimeout(() => {
                  layer.openPopup();
                }, 100);
              });
            },
            error: function (error) {
              console.error("Error fetching additional info:", error);
            },
          });
        }

        loadGeoJSON();

        // Add legend
        var legend = L.control({ position: "bottomleft" });
        legend.onAdd = function () {
          var div = L.DomUtil.create("div", "legend");
          div.innerHTML = `
                  <div class="legend p-3 border rounded shadow-sm bg-light">
                    <h4 class="fw-bold mb-3">Noise Level Legend</h4>
                    <p class="d-flex align-items-center">
                      <span class="color-box me-2" style="background-color:#FF0000; width: 20px; height: 20px; display: inline-block; border-radius: 4px;"></span>
                      <span class="text-danger fw-bold">High (70+ dB)</span>
                    </p>
                    <p class="d-flex align-items-center">
                      <span class="color-box me-2" style="background-color:#FFA500; width: 20px; height: 20px; display: inline-block; border-radius: 4px;"></span>
                      <span class="text-warning fw-bold">Medium (50-69 dB)</span>
                    </p>
                    <p class="d-flex align-items-center">
                      <span class="color-box me-2" style="background-color:#008000; width: 20px; height: 20px; display: inline-block; border-radius: 4px;"></span>
                      <span class="text-success fw-bold">Low (below 50 dB)</span>
                    </p>
                  </div>
                `;

          return div;
        };
        legend.addTo(map);

        // Layer controls
        var baseLayers = {
          Terrain: terrainLayer,
          Satellite: satelliteLayer,
        };
        L.control.layers(baseLayers).addTo(map);
      });
    </script>
  </body>
</html>
